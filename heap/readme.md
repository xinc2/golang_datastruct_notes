# 堆和堆排序 #

> `堆排序`是一种一种原地的、实践复杂度为$O(nlogn)$的排序算法
----------------------------

## 如何理解堆 ##

- 堆是一个完全二叉树
- 堆中每一个节点的值都必须大于等于(或小于等于)其子树中的每个节点

> 大顶堆: 对于每个节点的值都大于等于子树中每个节点值的堆
> 小顶堆: 对于每个节点的值都小于等于子树中每个节点值的堆

## 如何实现一个堆 ##

 堆排序的过程大致分解成两个大的步骤，建堆和排序。

- 建堆
    - 时间复杂度是 $O(n)$
    - 在不借助另一个数字的前提下，在原数组的基础上，原地建一个堆。具体由两种实现思路
        - 第一种: 在堆中插入一个元素的思路。尽管数组中包含 $n$ 个数据，但是我们可以假设，起初堆中只包含一个数据，就是下标为 $0$ 的数据, 然后，将下标从 $1$ 到 $n-1$ 的数据依次插入到堆中。这样我们就将包含 $n$ 个数据的数组，组织成了堆.
        - 第二种: 是从后往前处理数组，并且每个数据都是从上往下堆化.

- 排序
  
    - 建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。我们把它跟最后一个元素交换，那最大元素就放到了下标为 $n-1$ 的位置。
    - 当堆顶元素移除之后，我们把下标为 $n-1$ 的元素放到堆顶，然后再通过堆化的方法，将剩下的 $n-1$ 个元素重新构建成堆。堆化完成之后，我们再取堆顶的元素，放到下标是 $n-2$ 的位置，一直重复这个过程，直到最后堆中只剩下标为 $0$ 的一个元素，排序工作就完成了。

## 堆排序的时间复杂度、空间复杂度以及稳定性 ##

- 整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法
- 堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是$O(n)$, 排序过程的时间复杂度是 $O(n\log n)$ ，所以，堆排序整体的时间复杂度是 $O(n\log n)$ 。
- 堆排序不是稳定的排序算法，因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。
- 如果当前选择节点的下标是 $i$ ，那左子节点的下标就是 $2*i+1$ ，右子节点的下标就是 $2*i+2$ ，父节点的下标就是 $\frac{i-1}{2}$ 。
